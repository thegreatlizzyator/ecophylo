# -*- coding: utf-8 -*-
#
# This file is a part of the ecophylo package.
# 
# ecophylo is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the CeCILL FREE SOFTWARE LICENSE AGREEMENT
# along with ecophylo.

"""
Module responsible for generating prior distributions

@author: Elizabeth Barthelemy

should generate priors with different distributions - uniform, log-uniform etc.
should later find a way to constrain prior distributions using sepcial cases.


"""
import numpy as np
import pandas as pd
import sys

def counter(func):
    func.count += 1

def params(lim, nsim, distrib = "uniform"):
    """
    Make a list of parameters to test from prior distribution limits.

    Parameters
    ----------
    lim: list
        the inferior and superior limits of the prior distribution.
    nsim: int
        number of replicates.
    distrib: str, optional
        the type of prior distribution. The default is "uniform".

    Returns
    -------
    params: list
        a list of nsim parameter values.

    """
    if len(lim) != 2:
        sys.exit('inferior and superior prior limits are needed')
    counter(params)
    #only supports uniform prior distributions at the moment
    if distrib == "uniform":
        p = np.random.uniform(lim[0], lim[1], size = nsim)
    return p

def maketable(nsim, muprior, comprior, nepoch, pastprior, nsplit, massprior, npop, init_sizeprior, init_ratesprior, withmigr = False, verbose = False):

    # dummy checks for idiot-proofing:   
    if withmigr and npop is None or npop == 1 :
        sys.exit('There should be at least 2 populations to simulate migration')
    if nepoch > 1 and pastprior is None:
        sys.exit('There should be a prior distribution for past demographic changes dates when multiple epochs are simulated')
  
    params.count = 0 
    df = pd.DataFrame()

    if muprior is not None:
        df['mu'] = params(muprior, nsim)

    if comprior is not None:
        df['comsize'] = params(comprior, nsim)

    if pastprior is not None:
        pastsizes = [params(pastprior, nsim) for _ in range(nepoch)]
        colnames = ['pastsize{}'.format(i) for i in range(1,nepoch+1)]
        for i in range(nepoch):
            df[colnames[i]] = pastsizes[i]

    if withmigr and npop is not None:
        df['m'] = params([0,1], nsim)
    
    if init_sizeprior is not None and init_ratesprior is not None and npop is not None:
        initrates = [params(init_ratesprior, nsim) for _ in range(npop)]
        colnames = ['initrate{}'.format(i) for i in range(1,npop+1)]
        for i in range(npop):
            df[colnames[i]] = initrates[i]
        
        initsizes = [params(init_sizeprior, nsim) for _ in range(npop)]
        colnames = ['initsize{}'.format(i) for i in range(1,npop+1)]
        for i in range(npop):
            df[colnames[i]] = initsizes[i]

    if massprior is not None:
        massdates = [params(massprior, nsim) for _ in range(nsplit)]
        colnames = ['splitdate{}'.format(i) for i in range(1,nsplit+1)]
        for i in range(nsplit):
            df[colnames[i]] = massdates[i]

    if verbose:
        print(f"Simulating using {params.count} parameters")
     
    return df

def makemodel(nsim, model = "SGD", verbose = False):
    # call make table with specific param values depending on model
    # useful models: NTB -- neutral theory of biodiversity Hubbell 2001
    # ou SGD Speciation by Genetic Differentiation Manceau 2015 ?
    # Bottleneck ? 
    # Expansion ?
    # etc... 
    # if custom user must provide a parameter table generated by prior.maketable function
    if model != 'SGD':
        sys.exit('only SGD model is implemented at the moment')
    
    return 'implement later'
    

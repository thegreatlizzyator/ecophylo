---
title: "run_utils"
author: "Maxime Jaunatre"
date: "18/02/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
```

Small bit of code to help debug. Objective is to regroup here all examples of the python code.

# toPhylo.py

Work with python tree.

```{python}
from ete3 import Tree
tree = Tree()
# We create a random tree topology
tree.populate(5)
# or build from a newick style
tree = Tree('((A:1,(B:1,C:1)1:1)1:2,(D:1,E:1)1:5);')

print(tree)
node = tree.get_tree_root()
node = tree.children[0]
print(node)
node.dist * 1
node.dist * 0.5
node.dist * 0
```


init parameters of 

```{python}

node = tree.get_tree_root()

mu = 0
seed = 42

lambd = node.dist * mu

print(tree)

      /-1
   /-|
  |  |   /-8
  |   \-|
  |     |   /-0
--|      \-|
  |         \-2
  |
  |   /-7
  |  |
   \-|      /-6
     |   /-|
     |  |   \-9
      \-|
        |   /-5
         \-|
           |   /-3
            \-|
               \-4
tree.write()
'((1:65314.4,(8:15354.3,(0:2085.64,2:2085.64)1:13268.6)1:49960.1)1:361157,(7:69185.4,((6:9732.48,9:9732.48)1:14540.2,(5:16152.1,(3:3211.46,4:3211.46)1:12940.7)1:8120.56)1:44912.7)1:357286);'
import ecophylo as eco
phylo = eco.toPhylo(tree, 0.03, seed = 42)
print(phylo)

      /-1
   /-|
  |  |   /-8
  |   \-|
--|      \-0
  |
  |   /-7
  |  |
   \-|      /-5
     |   /-|
      \-|   \-3
        |
         \-6
phylo.write()
'((1:65314.4,(8:15354.3,0:15354.3)1:49960.1)1:361157,(7:69185.4,((5:16152.1,3:16152.1)1:8120.56,6:24272.7)1:44912.7)1:357286);'
```

```{python}
import ecophylo as eco
from ete3 import Tree
tree = Tree('((A:4,(B:4,C:3)1:4)1:5, Err: 1, (D:1,E:1)1:1);')
print(tree)
phylo = eco.toPhylo(tree, 0.5, seed = 42)

mano = Tree('(((A:5,(B:3, C:3))1:2,(D:2, E:2)1:5)1:2, Err:2, (F:3, G:3)1:6);')
print(mano)

mano.children[0]

phylo = eco.toPhylo(mano, 0.5, seed = 42)
print(phylo)
eco.getAbund(phylo, 7)

print(eco.toPhylo(mano, 0.5, seed = 42))

# mu = 0.5
# 
# # import numpy as np
# # np.random.seed(42)
# # for i in range(1,15): 
# #   print(i, end = ' ~ ')
# #   print(i*mu, end = ' ~ ')
# #   print(np.random.poisson(i*mu) >= 1)
# # print('done')
# 
# import msprime
# 
# treeseq = msprime.simulate(sample_size= 10, Ne = 1e5,
#                            random_seed= 42, demographic_events = None)
# tree = treeseq.first()
# node_labels = {u: str(u) for u in tree.nodes() if tree.is_sample(u)}
# tree = Tree(tree.newick(node_labels = node_labels))
# print(tree)
# phylo = eco.toPhylo(tree, 0.03, seed = 42)
# print(phylo)
# 
# t = eco.simulate(10, 1e5, 0.03, seed = 42)
# print(t)
```


```{python}
# work on population configuration objects
sample_size = 10
com_size = 500
npop = 2
m = 0
init_rates = None
init_sizes = None
past_sizes = None
changetime = None
split_dates = None
migrfrom = None
migrto = None
verbose = False
seed = 42

# init variables
popchange = []
massmigration = []
popconfig = None
migration = None

# make past demographic changes between different time frames
if past_sizes is not None and changetime is not None:
  if len(past_sizes) != len(changetime):
    sys.exit("There should be as many sizes as there are past epochs")
    popchange = pastdemo.demographic_events(changetime, past_sizes)
    
# make island model
if npop > 1:
  if init_sizes is None or init_rates is None:
    sys.exit("Initial population sizes and growth rates should be provided when there are more than one population (npop>1)")
    migration = islmodel.migration_matrix(npop, m)
    samples = np.ones(npop, dtype=int)*sample_size
    popconfig = islmodel.population_configurations(samples, init_sizes, init_rates)
    
  # possible mass migration between populations
  if split_dates is not None:
    # implement option later for limited mass dispersal
    M = 1
    massmigration = islmodel.mass_migrations(split_dates, migrfrom, migrto, M)
          
  demography = popchange + massmigration
  if len(demography) == 0:
    demography = None
            
  # if verbose should print the demography debugger - only for debugging purposes!!! 
  if verbose: 
    dd = msprime.DemographyDebugger(Ne = com_size, 
    demographic_events= demography, 
    migration_matrix= migration, 
    population_configurations= popconfig)
    dd.print_history()
    
  if npop > 1:
    treeseq = msprime.simulate(Ne = com_size,
    random_seed= seed,
    population_configurations = popconfig, # ici joue le mÃªme role que sample_size
    migration_matrix = migration,
    demographic_events = demography)
  else: 
    treeseq = msprime.simulate(sample_size= sample_size,# same as population config
    Ne = com_size,
    random_seed= seed,
    demographic_events = demography)
    
```


```{python, out of africa}
import math
import msprime

# First we set out the maximum likelihood values of the various parameters
# given in Table 1.
N_A = 7300
N_B = 2100
N_AF = 12300
N_EU0 = 1000
N_AS0 = 510
# Times are provided in years, so we convert into generations.
generation_time = 25
T_AF = 220e3 / generation_time
T_B = 140e3 / generation_time
T_EU_AS = 21.2e3 / generation_time
# We need to work out the starting (diploid) population sizes based on
# the growth rates provided for these two populations
r_EU = 0.004
r_AS = 0.0055
N_EU = N_EU0 / math.exp(-r_EU * T_EU_AS)
N_AS = N_AS0 / math.exp(-r_AS * T_EU_AS)
# Migration rates during the various epochs.
m_AF_B = 25e-5
m_AF_EU = 3e-5
m_AF_AS = 1.9e-5
m_EU_AS = 9.6e-5
# Population IDs correspond to their indexes in the population
# configuration array. Therefore, we have 0=YRI, 1=CEU and 2=CHB
# initially.
population_configurations = [
  msprime.PopulationConfiguration(
    sample_size=0, initial_size=N_AF),
  msprime.PopulationConfiguration(
    sample_size=1, initial_size=N_EU, growth_rate=r_EU),
  msprime.PopulationConfiguration(
    sample_size=1, initial_size=N_AS, growth_rate=r_AS)
]
migration_matrix = [
  [      0, m_AF_EU, m_AF_AS],
  [m_AF_EU,       0, m_EU_AS],
  [m_AF_AS, m_EU_AS,       0],
]
demographic_events = [
  # CEU and CHB merge into B with rate changes at T_EU_AS
  msprime.MassMigration(
    time=T_EU_AS, source=2, destination=1, proportion=1.0),
  msprime.MigrationRateChange(time=T_EU_AS, rate=0),
  msprime.MigrationRateChange(
    time=T_EU_AS, rate=m_AF_B, matrix_index=(0, 1)),
  msprime.MigrationRateChange(
    time=T_EU_AS, rate=m_AF_B, matrix_index=(1, 0)),
  msprime.PopulationParametersChange(
    time=T_EU_AS, initial_size=N_B, growth_rate=0, population_id=1),
  # Population B merges into YRI at T_B
  msprime.MassMigration(
    time=T_B, source=1, destination=0, proportion=1.0),
  msprime.MigrationRateChange(time=T_B, rate=0),
  # Size changes to N_A at T_AF
  msprime.PopulationParametersChange(
    time=T_AF, initial_size=N_A, population_id=0)
]
dd = msprime.DemographyDebugger(
  population_configurations=population_configurations,
  migration_matrix=migration_matrix,
  demographic_events=demographic_events)
dd.print_history()
```



```{python, out of africa}
import math
import msprime


# initial pop size
pop1 = 500
pop2 = 420
gr1 = 0.05
gr2 = 0

samp1 = 5
samp2 = 4

population_configurations = [
  msprime.PopulationConfiguration(
    sample_size = 2,
    initial_size=pop1),
    
  msprime.PopulationConfiguration(
    sample_size = 2,
    initial_size=pop2, 
    growth_rate=gr2)
]

migration_matrix = [
  [ 0, 0],
  [ 0, 0]
]

demographic_events = [
  msprime.PopulationParametersChange(
    time= 20, initial_size=800, population_id=0)
]

dd = msprime.DemographyDebugger(
  population_configurations=population_configurations,
  migration_matrix=migration_matrix,
  demographic_events=demographic_events)
dd.print_history()

# S_{t-1} = S_{t0} * exp(-0.05 * Dt)
# = 9.643749e-20


treeseq = msprime.simulate(
  random_seed= 42,
  population_configurations = population_configurations,
  migration_matrix = migration_matrix,
  demographic_events = demography)
  
tree = treeseq.first()
print(tree.draw(format = 'unicode'))
# demographic_events = [
#   # CEU and CHB merge into B with rate changes at T_EU_AS
#   msprime.MassMigration(
#     time=T_EU_AS, source=2, destination=1, proportion=1.0),
#   msprime.MigrationRateChange(time=T_EU_AS, rate=0),
#   msprime.MigrationRateChange(
#     time=T_EU_AS, rate=m_AF_B, matrix_index=(0, 1)),
#   msprime.MigrationRateChange(
#     time=T_EU_AS, rate=m_AF_B, matrix_index=(1, 0)),
#   msprime.PopulationParametersChange(
#     time=T_EU_AS, initial_size=N_B, growth_rate=0, population_id=1),
#   # Population B merges into YRI at T_B
#   msprime.MassMigration(
#     time=T_B, source=1, destination=0, proportion=1.0),
#   msprime.MigrationRateChange(time=T_B, rate=0),
#   # Size changes to N_A at T_AF
#   msprime.PopulationParametersChange(
#     time=T_AF, initial_size=N_A, population_id=0)
# ]

init = 2
past = [2, 4, 2, 5]

time = [10, 20, 30, 40]

tb = 0
sb = init
gr = []

for i in range(len(past)):
  gr.append(math.log(past[i]/sb)/(time[i] - tb))
  sb = past[i]
  tb = time[i]
print(gr)


```

---
title: "run_utils"
author: "Maxime Jaunatre"
date: "18/02/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
```

Small bit of code to help debug. Objective is to regroup here all examples of the python code.

# toPhylo.py

Work with python tree.

```{python}
from ete3 import Tree
tree = Tree()
# We create a random tree topology
tree.populate(5)
# or build from a newick style
tree = Tree('((A:1,(B:1,C:1)1:1)1:2,(D:1,E:1)1:5);')

print(tree)
node = tree.get_tree_root()
node = tree.children[0]
print(node)
node.dist * 1
node.dist * 0.5
node.dist * 0
```


init parameters of 

```{python}

node = tree.get_tree_root()

mu = 0
seed = 42

lambd = node.dist * mu

print(tree)

      /-1
   /-|
  |  |   /-8
  |   \-|
  |     |   /-0
--|      \-|
  |         \-2
  |
  |   /-7
  |  |
   \-|      /-6
     |   /-|
     |  |   \-9
      \-|
        |   /-5
         \-|
           |   /-3
            \-|
               \-4
tree.write()
'((1:65314.4,(8:15354.3,(0:2085.64,2:2085.64)1:13268.6)1:49960.1)1:361157,(7:69185.4,((6:9732.48,9:9732.48)1:14540.2,(5:16152.1,(3:3211.46,4:3211.46)1:12940.7)1:8120.56)1:44912.7)1:357286);'
import ecophylo as eco
phylo = eco.toPhylo(tree, 0.03, seed = 42)
print(phylo)

      /-1
   /-|
  |  |   /-8
  |   \-|
--|      \-0
  |
  |   /-7
  |  |
   \-|      /-5
     |   /-|
      \-|   \-3
        |
         \-6
phylo.write()
'((1:65314.4,(8:15354.3,0:15354.3)1:49960.1)1:361157,(7:69185.4,((5:16152.1,3:16152.1)1:8120.56,6:24272.7)1:44912.7)1:357286);'
```

```{python}
import ecophylo as eco
from ete3 import Tree
tree = Tree('((A:4,(B:4,C:3)1:4)1:5, Err: 1, (D:1,E:1)1:1);')
print(tree)
phylo = eco.toPhylo(tree, 0.5, seed = 42)

mano = Tree('(((A:5,(B:3, C:3))1:2,(D:2, E:2)1:5)1:2, Err:2, (F:3, G:3)1:6);')
print(mano)

mano.children[0]

phylo = eco.toPhylo(mano, 0.5, seed = 42)
print(phylo)
eco.getAbund(phylo, 7)

print(eco.toPhylo(mano, 0.5, seed = 42))

# mu = 0.5
# 
# # import numpy as np
# # np.random.seed(42)
# # for i in range(1,15): 
# #   print(i, end = ' ~ ')
# #   print(i*mu, end = ' ~ ')
# #   print(np.random.poisson(i*mu) >= 1)
# # print('done')
# 
# import msprime
# 
# treeseq = msprime.simulate(sample_size= 10, Ne = 1e5,
#                            random_seed= 42, demographic_events = None)
# tree = treeseq.first()
# node_labels = {u: str(u) for u in tree.nodes() if tree.is_sample(u)}
# tree = Tree(tree.newick(node_labels = node_labels))
# print(tree)
# phylo = eco.toPhylo(tree, 0.03, seed = 42)
# print(phylo)
# 
# t = eco.simulate(10, 1e5, 0.03, seed = 42)
# print(t)
```


```{python}
# work on population configuration objects
sample_size = 10
com_size = 500
npop = 2
m = 0
init_rates = None
init_sizes = None
past_sizes = None
changetime = None
split_dates = None
migrfrom = None
migrto = None
verbose = False
seed = 42

# init variables
popchange = []
massmigration = []
popconfig = None
migration = None

# make past demographic changes between different time frames
if past_sizes is not None and changetime is not None:
  if len(past_sizes) != len(changetime):
    sys.exit("There should be as many sizes as there are past epochs")
    popchange = pastdemo.demographic_events(changetime, past_sizes)
    
# make island model
if npop > 1:
  if init_sizes is None or init_rates is None:
    sys.exit("Initial population sizes and growth rates should be provided when there are more than one population (npop>1)")
    migration = islmodel.migration_matrix(npop, m)
    samples = np.ones(npop, dtype=int)*sample_size
    popconfig = islmodel.population_configurations(samples, init_sizes, init_rates)
    
  # possible mass migration between populations
  if split_dates is not None:
    # implement option later for limited mass dispersal
    M = 1
    massmigration = islmodel.mass_migrations(split_dates, migrfrom, migrto, M)
          
  demography = popchange + massmigration
  if len(demography) == 0:
    demography = None
            
  # if verbose should print the demography debugger - only for debugging purposes!!! 
  if verbose: 
    dd = msprime.DemographyDebugger(Ne = com_size, 
    demographic_events= demography, 
    migration_matrix= migration, 
    population_configurations= popconfig)
    dd.print_history()
    
  if npop > 1:
    treeseq = msprime.simulate(Ne = com_size,
    random_seed= seed,
    population_configurations = popconfig, # ici joue le mÃªme role que sample_size
    migration_matrix = migration,
    demographic_events = demography)
  else: 
    treeseq = msprime.simulate(sample_size= sample_size,# same as population config
    Ne = com_size,
    random_seed= seed,
    demographic_events = demography)
    
```



```{python, out of africa}
import math
import msprime


# initial pop size
pop1 = 500
pop2 = 420
gr1 = 0.05
gr2 = 0

samp1 = 5
samp2 = 4

population_configurations = [
  msprime.PopulationConfiguration(
    sample_size = 2,
    initial_size=pop1),
    
  msprime.PopulationConfiguration(
    sample_size = 2,
    initial_size=pop2, 
    growth_rate=gr2)
]

migration_matrix = [
  [ 0, 0],
  [ 0, 0]
]

demographic_events = [
  msprime.PopulationParametersChange(
    time= 20, initial_size=800, population_id=0)
]

dd = msprime.DemographyDebugger(
  population_configurations=population_configurations,
  migration_matrix=migration_matrix,
  demographic_events=demographic_events)
dd.print_history()

# S_{t-1} = S_{t0} * exp(-0.05 * Dt)
# = 9.643749e-20


treeseq = msprime.simulate(
  random_seed= 42,
  population_configurations = population_configurations,
  migration_matrix = migration_matrix,
  demographic_events = demography)
  
tree = treeseq.first()
print(tree.draw(format = 'unicode'))
# demographic_events = [
#   # CEU and CHB merge into B with rate changes at T_EU_AS
#   msprime.MassMigration(
#     time=T_EU_AS, source=2, destination=1, proportion=1.0),
#   msprime.MigrationRateChange(time=T_EU_AS, rate=0),
#   msprime.MigrationRateChange(
#     time=T_EU_AS, rate=m_AF_B, matrix_index=(0, 1)),
#   msprime.MigrationRateChange(
#     time=T_EU_AS, rate=m_AF_B, matrix_index=(1, 0)),
#   msprime.PopulationParametersChange(
#     time=T_EU_AS, initial_size=N_B, growth_rate=0, population_id=1),
#   # Population B merges into YRI at T_B
#   msprime.MassMigration(
#     time=T_B, source=1, destination=0, proportion=1.0),
#   msprime.MigrationRateChange(time=T_B, rate=0),
#   # Size changes to N_A at T_AF
#   msprime.PopulationParametersChange(
#     time=T_AF, initial_size=N_A, population_id=0)
# ]

def mergesizes2rates(past_values, changetime, init_size = None , sizevalues = True):
    """
    Compute the growth rates corresponding to a set of past sizes at different 
    times for a single population with a given initial size

    Parameters
    ----------
    past_sizes : list of int
        positive values
        the sizes of the population in the past
        # TODO : should have the same length as time
    init_size : list of int
        positive value
        the initial size of the population
        # TODO : same len as past_value matrix
    changetime : list of int
        None by default
        times at which the population size changes
        # TODO : should have the same length as t past_sizes
    sizesvalues : bool
        indicate if the past_values list is a matrix of sizes or growth rates.

    Returns
    -------
    a list object containing the different growth rates of a given population
    at each given time period
    
    """

    npop = len(past_values)
    # aggregate the times.
    nrow = changetime[0]
    for i in range(1,len(changetime)):
      nrow = sorted(nrow + list(set(changetime[i]) - set(nrow) ))
    
    matrix = [nrow]
    for i in range(npop) :
      tmpsize = list(past_values[i])
      tmptime = list(changetime[i])
      res = [] # init empty list
      for ii in  nrow:
        
        if len(tmptime) == 0 : # if no time left for this pop
          res.append('NA') 
          continue
        
        if ii == tmptime[0]: # when time is defined for a pop
          val = tmpsize.pop(0)
          tmptime.remove(tmptime[0])
          if sizevalues : # compute directly the growrate
            tmp = val
            val = eco.sizes2rates(init_size[i], 
                                  past_sizes = [val], 
                                  changetime = [ii])[0]
            init_size[i] = tmp
          
          res.append(val) # add the value
          # remove previous NA (only if its grates)
          place = len(res)-1
          while res[place-1] == 'NA' and place >= 0 :
            place-=1
          
          # change NA with values
          for iii in range(place, len(res)) :
            res[iii] = val
        else: # if nothing defined for this pop at this time
          res.append('NA')
      
      if(res[-1] == 'NA'): # if ending with NA, expand last known rate
        place = len(res)-1
        while res[place-1] == 'NA' and place >= 0 :
          place-=1
          # change NA with values
        for iii in range(place, len(res)) :
          res[iii] = res[place-1]
      matrix.append(res) # append this pop list in matrix
    return matrix

init_size = [2, 3]
past_values = [[0.2, 0.1, -0.09, 0.009],
[0.42, -0.4, 0.07, 0.42,0.01]]
changetime = [[10, 20, 30, 40],
[10, 15, 21, 60, 70]]
sizevalues = False

[[  10,   15,   20,   21,   30,   40,   60,  70], 
 [0.42, -0.4, 0.07, 0.07, 0.42, 0.42, 0.42, 0.01]]

init_size = [2, 3]
past_values = [[4, 3, 10, 7],
[1, 2, 5, 2,3]]
changetime = [[10, 20, 30, 40],
[10, 15, 21, 60, 70]]
sizevalues = True

init_size = [2]
past_values = [[0.2, 0.1, -0.09, 0.009]]
changetime = [[10, 20, 30, 40]]
sizevalues = False
mergesizes2rates([[0.2, 0.1, -0.09, 0.009]], [[10, 20, 30, 40]], [2], False)

mergesizes2rates([[3, 5, 3, 4]], [[10, 20, 30, 40]], [2], True)

import ecophylo as eco
mergesizes2rates(past_values, changetime, init_size, sizevalues)

eco.sizes2rates(2, past_sizes = [2],  changetime = [10])[0]

```

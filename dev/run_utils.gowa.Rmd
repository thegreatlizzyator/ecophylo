---
title: "run_utils"
author: "Maxime Jaunatre"
date: "18/02/2021"
output:
  html_document: default
  pdf_document: default
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
knitr::knit_engines$set(python = reticulate::eng_python)
```

Small bit of code to help debug. Objective is to regroup here all examples of the python code.

### Population configurations

```{python, include = FALSE, eval = FALSE}
import msprime
import ecophylo as eco
# cas 0
init_sizes = [2]
past_sizes = [[4, 3, 7]]
changetime = [[10, 20, 30]]
samples = [1]
rates = [0.02]
stable_pop = True
if rates != None :
  stable_pop = False

# cas 1
init_sizes = [2, 3]
past_sizes = [[4, 3, 7], [1, 2, 5]]
changetime = [[10, 20, 30], [10, 15, 60]]
samples = [1, 1]
rates = [0.02, 0.05]
stable_pop = True
if rates != None :
  stable_pop = False

# if rates == None :
#   rates = []

if True :
  pastdemo = []
  sizes = eco.mergesizes2rates(past_sizes, changetime, init_sizes, False)
  times = sizes[0]
  print(sizes)
  
  if stable_pop:
    rates = [ [0]*len(times) for _ in range(len(changetime))]
    rates = [times] + rates
  elif rates != None : # if rates are provided, fixed rates for all the epochs
    if len(rates) == len(changetime) and all(isinstance(x, (int,float)) for x in rates):
      tmp_rates = [times]
      for i in range(len(changetime)):
        tmp_rates = tmp_rates + [[rates[i]]*len(times)]
      rates = tmp_rates
  #   else :
  #     rates = eco.mergesizes2rates(rates, changetime, init_sizes, True)
  else : 
    rates = eco.mergesizes2rates(past_sizes, changetime, init_sizes, True)
  print(rates)
  print(init_sizes)
  pc = [] # initial population configurations
  for i in range(len(changetime)):
    pc = pc + [msprime.PopulationConfiguration(sample_size = samples[i], growth_rate= rates[i+1][0],  initial_size = init_sizes[i] )]
    rates[i + 1].remove(rates[i+1][0]) # remove first rate
    rates[i+1].append(rates[i+1][-1]) # duplicate late rate for infinity
  print(rates)
  
  for i in range(len(times)): # later populations parameter changes
    for ii in range(len(changetime)):
      pastdemo = pastdemo +  [msprime.PopulationParametersChange( time=times[i], initial_size = sizes[ii+1][i], growth_rate = rates[ii+1][i], population_id= ii) ]
  
migration_matrix = [ [ 0, 1], [ 1, 0] ]

dd = msprime.DemographyDebugger(
  population_configurations=pc, 
  demographic_events=pastdemo)
dd.print_history()

treeseq = msprime.simulate(
  random_seed= 42,
  population_configurations = pc,
  migration_matrix = migration_matrix,
  demographic_events = pastdemo)
  
tree = treeseq.first()
print(tree.draw(format = 'unicode'))
```

### getAbund examples
```{python}
from ete3 import Tree
tree = Tree('(((A:5,(B:3, C:3))1:2,(D:2, E:2)1:5)1:2, (F:3, G:3)1:6);')
print(tree)
import ecophylo as eco
phylo = eco.toPhylo(tree, 0.5, seed = 42)
print(phylo)
eco.getAbund(phylo)
```


### Writing simulate_dolly
```{python}
import msprime
sample_size = 10 # the sample size
com_size = 500 # the size of the metacommunity (sensu Hubbell, 2001)
mu = 0.01
init_rates = None
past_sizes = None
changetime = None
mrca = None
m = 0
verbose = True
seed = 42

# def simulate_dolly(sample_size, com_size, mu, init_rates = None, 
#              past_sizes = None, changetime = None, mrca = None, 
#              m = 0, verbose = False, seed = None):


# parameters that will be used later
split_dates = None # won't be used
migrfrom = None # won't be used
migrto = None # won't be used

migration = None
popconfig = None # TODO here !

# Idiotproof
if not isinstance(seed, (int,float)):
  sys.exit('seed must be an integer')
if isinstance(seed, float):
  seed = int(seed)
# TODO : idiotproof
# do dummy checks here --> try to make code stupid-proof
if sample_size >= com_size:
  sys.exit("Sample size should not exceed community size")

if isinstance(sample_size, int): # cas a une pop !
  print('here')
  demography = None
  # make past demographic changes between different time frames
  if past_sizes is not None and changetime is not None:
    if len(past_sizes) != len(changetime):
      sys.exit("There should be as many sizes as there are past epochs")
    demography = pastdemo.demographic_events(changetime, past_sizes)
    # simulatation
  treeseq = msprime.simulate(sample_size= sample_size,
                             Ne = com_size,
                             random_seed= seed,
                             demographic_events = demography)

tree = treeseq.first()
if verbose: print(tree.draw(format = 'unicode'))


else : # make island model
  npop = len(sample_size)
  init_sizes = sample_size
  
  # TODO : doc !!!
  popchange = []
  massmigration = []
  
  # TODO : init the populations
  
  if init_sizes is None or init_rates is None:
    sys.exit("Initial population sizes and growth rates should be provided when there are more than one population (npop>1)")
    
    # subpops =  npop
    migration = islmodel.migration_matrix(npop, m)
    
    samples = np.ones(npop, dtype=int)*sample_size
    # TODO : allow differential sampling in pop (provide sample list same length as npop)
    popconfig = islmodel.population_configurations(samples, init_sizes, init_rates)
    
    # possible mass migration between populations
    if split_dates is not None:
        # implement option later for limited mass dispersal
        massmigration = islmodel.mass_migrations(split_dates, migrfrom, migrto, migr = 1)
  
  demography = popchange + massmigration
  if len(demography) == 0:
    demography = None
  
  treeseq = msprime.simulate(Ne = com_size,
                             random_seed= seed,
                             population_configurations = popconfig,
                             migration_matrix = migration,
                             demographic_events = demography)

# if verbose should print the demography debugger - only for debugging purposes!!! 
if verbose: 
    dd = msprime.DemographyDebugger(Ne = com_size, 
                                    demographic_events= demography, 
                                    migration_matrix= migration, 
                                    population_configurations= popconfig)
        # dd.print_history()
        dd.print_history(output=sys.stderr)

tree = treeseq.first()
if verbose: print(tree.draw(format = 'unicode'))
if mrca is not None:
  if tree.time(tree.root) > mrca : 
    raise Exception(f"Simulated MRCA ({tree.time(tree.root)}) predates"+
  " fixed limit ({mrca})")
#print(tree.draw(format="unicode"))
node_labels = {u: str(u) for u in tree.nodes() if tree.is_sample(u)}
tree = Tree(tree.newick(node_labels = node_labels))
phylo = phylogen.toPhylo(tree, mu, seed = seed)

# return phylo
```

